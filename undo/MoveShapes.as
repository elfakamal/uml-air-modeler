package { // MoveShapes.as  by Daniel Freeman http://www.e2easy.co.cc		import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;		public class MoveShapes extends Sprite { // Note that you don't need Flex to turn this pure ActionScript 3 example into an AIR application.// You can use free command line tools.// amxmlc (compiler) and adt (which converts a .swf file into a .air file).				private static const MOVESHAPE:String='MoveShapes.MOVESHAPE';				private const colours:Array=[0xccccff,0xccffcc,0xffcccc,0xffffcc];		private const gap:int=128;		private const margin:int=64;		private const ycoord:int=128;				private var history:History=new History();  		public function MoveShapes(screen:Sprite=null) {			if (screen!=null) screen.addChild(this); // Put some coloured shapes on the screen. 			for (var i:int=0;i<colours.length;i++) {				new MyShape(this,i*gap+margin,ycoord,colours[i],i+3);				} // Set up listeners.			addEventListener(MouseEvent.MOUSE_DOWN,mouseDownEvent);			stage.addEventListener(KeyboardEvent.KEY_DOWN,keypressed);		}						private function mouseDownEvent(ev:MouseEvent):void {trace('md');			var shape:MyShape=ev.target as MyShape;				// This is the important bit.  The document is about to change.// Make sure you save everything that you need to restore it.// The position of the shape, before you move it.  And its depth, before you bring it to the front. 			history.record(MOVESHAPE,[shape,shape.x,shape.y,getChildIndex(shape)]);				// Change the depth of the shape.  Bring it to the front.			setChildIndex(shape,numChildren-1);				// Start dragging the shape.			shape.startDrag();				// Set up a listener to detect mouseup.			stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpEvent);		}						private function mouseUpEvent(ev:MouseEvent):void {// Stop dragging.			stopDrag();			stage.removeEventListener(MouseEvent.MOUSE_UP,mouseUpEvent);		}						private function keypressed(ev:KeyboardEvent):void {			var ch:String=String.fromCharCode(ev.charCode).toLowerCase();	// Press z=undo.  press y=redo.			switch (ch) {				case 'z':undo();break;				case 'y':redo();				}		}						private function undo():void {			var obj:HistoryItem=history.undo();			// Notice we are passing a true undo flag here.			if (obj!=null) doaction(obj.action,obj.actionParameters,true);		}						private function redo():void {			var obj:HistoryItem=history.redo();			// And notice we are passing false here.  			if (obj!=null) doaction(obj.redoAction,obj.redoParameters,false);		}						private function doaction(action:String,parameters:Array,canundo:Boolean):void {	// Depending on the action, we call a specific method that restores the document state for that action.// We pass the Undo flag to this method.						switch (action) {				case MOVESHAPE:restore(parameters,canundo);break;				// There is only one type of action in this simple example.// But a real application would probably have several possible actions.// Several cases.							}		}						private function restore(parameters:Array,canundo:Boolean):void {			var what:MyShape=parameters[0] as MyShape;  // Which shape was affected?			// When we do an Undo, we must save a document state enabling us to Redo.// Just like before, we save the position of the shape and its depth. 			if (canundo) history.redoaction(MOVESHAPE,[what,what.x,what.y,getChildIndex(what)]);			// Restore position.			what.x=parameters[1] as Number;			what.y=parameters[2] as Number;			// Restore depth.			setChildIndex(what,parameters[3] as int);		}	 	}}